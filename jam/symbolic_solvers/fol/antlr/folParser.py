# Generated from fol.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\30")
        buf.write("\u00b9\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3\2")
        buf.write("\7\2\34\n\2\f\2\16\2\37\13\2\3\2\3\2\6\2#\n\2\r\2\16\2")
        buf.write("$\3\2\3\2\6\2)\n\2\r\2\16\2*\3\2\3\2\7\2/\n\2\f\2\16\2")
        buf.write("\62\13\2\3\2\3\2\3\3\3\3\7\38\n\3\f\3\16\3;\13\3\3\3\3")
        buf.write("\3\3\3\7\3@\n\3\f\3\16\3C\13\3\3\4\3\4\3\4\3\4\3\4\7\4")
        buf.write("J\n\4\f\4\16\4M\13\4\3\4\3\4\3\5\3\5\7\5S\n\5\f\5\16\5")
        buf.write("V\13\5\3\5\3\5\3\5\7\5[\n\5\f\5\16\5^\13\5\3\6\3\6\7\6")
        buf.write("b\n\6\f\6\16\6e\13\6\3\6\3\6\3\6\7\6j\n\6\f\6\16\6m\13")
        buf.write("\6\3\7\3\7\3\7\3\7\3\7\3\7\7\7u\n\7\f\7\16\7x\13\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\7\7\u0085\n\7")
        buf.write("\f\7\16\7\u0088\13\7\3\7\3\7\5\7\u008c\n\7\3\7\3\7\7\7")
        buf.write("\u0090\n\7\f\7\16\7\u0093\13\7\3\7\3\7\7\7\u0097\n\7\f")
        buf.write("\7\16\7\u009a\13\7\3\7\3\7\7\7\u009e\n\7\f\7\16\7\u00a1")
        buf.write("\13\7\3\b\3\b\5\b\u00a5\n\b\3\t\3\t\3\t\3\t\3\t\5\t\u00ac")
        buf.write("\n\t\3\n\3\n\5\n\u00b0\n\n\3\13\3\13\3\f\3\f\3\f\3\r\3")
        buf.write("\r\3\r\2\3\f\16\2\4\6\b\n\f\16\20\22\24\26\30\2\2\2\u00c5")
        buf.write("\2\35\3\2\2\2\4\65\3\2\2\2\6D\3\2\2\2\bP\3\2\2\2\n_\3")
        buf.write("\2\2\2\f\u008b\3\2\2\2\16\u00a4\3\2\2\2\20\u00ab\3\2\2")
        buf.write("\2\22\u00af\3\2\2\2\24\u00b1\3\2\2\2\26\u00b3\3\2\2\2")
        buf.write("\30\u00b6\3\2\2\2\32\34\7\25\2\2\33\32\3\2\2\2\34\37\3")
        buf.write("\2\2\2\35\33\3\2\2\2\35\36\3\2\2\2\36 \3\2\2\2\37\35\3")
        buf.write("\2\2\2 \"\5\4\3\2!#\7\25\2\2\"!\3\2\2\2#$\3\2\2\2$\"\3")
        buf.write("\2\2\2$%\3\2\2\2%&\3\2\2\2&(\5\b\5\2\')\7\25\2\2(\'\3")
        buf.write("\2\2\2)*\3\2\2\2*(\3\2\2\2*+\3\2\2\2+,\3\2\2\2,\60\5\n")
        buf.write("\6\2-/\7\25\2\2.-\3\2\2\2/\62\3\2\2\2\60.\3\2\2\2\60\61")
        buf.write("\3\2\2\2\61\63\3\2\2\2\62\60\3\2\2\2\63\64\7\2\2\3\64")
        buf.write("\3\3\2\2\2\659\7\4\2\2\668\7\25\2\2\67\66\3\2\2\28;\3")
        buf.write("\2\2\29\67\3\2\2\29:\3\2\2\2:<\3\2\2\2;9\3\2\2\2<A\5\6")
        buf.write("\4\2=>\7\25\2\2>@\5\6\4\2?=\3\2\2\2@C\3\2\2\2A?\3\2\2")
        buf.write("\2AB\3\2\2\2B\5\3\2\2\2CA\3\2\2\2DE\5\30\r\2EF\7\n\2\2")
        buf.write("FK\5\16\b\2GH\7\7\2\2HJ\5\16\b\2IG\3\2\2\2JM\3\2\2\2K")
        buf.write("I\3\2\2\2KL\3\2\2\2LN\3\2\2\2MK\3\2\2\2NO\7\13\2\2O\7")
        buf.write("\3\2\2\2PT\7\5\2\2QS\7\25\2\2RQ\3\2\2\2SV\3\2\2\2TR\3")
        buf.write("\2\2\2TU\3\2\2\2UW\3\2\2\2VT\3\2\2\2W\\\5\f\7\2XY\7\25")
        buf.write("\2\2Y[\5\f\7\2ZX\3\2\2\2[^\3\2\2\2\\Z\3\2\2\2\\]\3\2\2")
        buf.write("\2]\t\3\2\2\2^\\\3\2\2\2_c\7\6\2\2`b\7\25\2\2a`\3\2\2")
        buf.write("\2be\3\2\2\2ca\3\2\2\2cd\3\2\2\2df\3\2\2\2ec\3\2\2\2f")
        buf.write("k\5\f\7\2gh\7\25\2\2hj\5\f\7\2ig\3\2\2\2jm\3\2\2\2ki\3")
        buf.write("\2\2\2kl\3\2\2\2l\13\3\2\2\2mk\3\2\2\2no\b\7\1\2op\5\30")
        buf.write("\r\2pq\7\n\2\2qv\5\16\b\2rs\7\7\2\2su\5\16\b\2tr\3\2\2")
        buf.write("\2ux\3\2\2\2vt\3\2\2\2vw\3\2\2\2wy\3\2\2\2xv\3\2\2\2y")
        buf.write("z\7\13\2\2z\u008c\3\2\2\2{|\7\n\2\2|}\5\f\7\2}~\7\13\2")
        buf.write("\2~\u008c\3\2\2\2\177\u0080\7\f\2\2\u0080\u008c\5\f\7")
        buf.write("\5\u0081\u0082\5\22\n\2\u0082\u0086\5\26\f\2\u0083\u0085")
        buf.write("\7\25\2\2\u0084\u0083\3\2\2\2\u0085\u0088\3\2\2\2\u0086")
        buf.write("\u0084\3\2\2\2\u0086\u0087\3\2\2\2\u0087\u0089\3\2\2\2")
        buf.write("\u0088\u0086\3\2\2\2\u0089\u008a\5\f\7\3\u008a\u008c\3")
        buf.write("\2\2\2\u008bn\3\2\2\2\u008b{\3\2\2\2\u008b\177\3\2\2\2")
        buf.write("\u008b\u0081\3\2\2\2\u008c\u009f\3\2\2\2\u008d\u0091\f")
        buf.write("\4\2\2\u008e\u0090\7\25\2\2\u008f\u008e\3\2\2\2\u0090")
        buf.write("\u0093\3\2\2\2\u0091\u008f\3\2\2\2\u0091\u0092\3\2\2\2")
        buf.write("\u0092\u0094\3\2\2\2\u0093\u0091\3\2\2\2\u0094\u0098\5")
        buf.write("\20\t\2\u0095\u0097\7\25\2\2\u0096\u0095\3\2\2\2\u0097")
        buf.write("\u009a\3\2\2\2\u0098\u0096\3\2\2\2\u0098\u0099\3\2\2\2")
        buf.write("\u0099\u009b\3\2\2\2\u009a\u0098\3\2\2\2\u009b\u009c\5")
        buf.write("\f\7\5\u009c\u009e\3\2\2\2\u009d\u008d\3\2\2\2\u009e\u00a1")
        buf.write("\3\2\2\2\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0")
        buf.write("\r\3\2\2\2\u00a1\u009f\3\2\2\2\u00a2\u00a5\5\24\13\2\u00a3")
        buf.write("\u00a5\5\26\f\2\u00a4\u00a2\3\2\2\2\u00a4\u00a3\3\2\2")
        buf.write("\2\u00a5\17\3\2\2\2\u00a6\u00ac\7\r\2\2\u00a7\u00ac\7")
        buf.write("\16\2\2\u00a8\u00ac\7\17\2\2\u00a9\u00ac\7\20\2\2\u00aa")
        buf.write("\u00ac\7\21\2\2\u00ab\u00a6\3\2\2\2\u00ab\u00a7\3\2\2")
        buf.write("\2\u00ab\u00a8\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ab\u00aa")
        buf.write("\3\2\2\2\u00ac\21\3\2\2\2\u00ad\u00b0\7\22\2\2\u00ae\u00b0")
        buf.write("\7\23\2\2\u00af\u00ad\3\2\2\2\u00af\u00ae\3\2\2\2\u00b0")
        buf.write("\23\3\2\2\2\u00b1\u00b2\7\3\2\2\u00b2\25\3\2\2\2\u00b3")
        buf.write("\u00b4\7\b\2\2\u00b4\u00b5\7\3\2\2\u00b5\27\3\2\2\2\u00b6")
        buf.write("\u00b7\7\3\2\2\u00b7\31\3\2\2\2\26\35$*\609AKT\\ckv\u0086")
        buf.write("\u008b\u0091\u0098\u009f\u00a4\u00ab\u00af")
        return buf.getvalue()


class folParser ( Parser ):

    grammarFileName = "fol.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'Predicates:'", "'Premises:'", 
                     "'Conclusion:'", "','", "'?'", "'_'", "'('", "')'", 
                     "'\u00AC'", "'\u2227'", "'\u2228'", "'\u2192'", "'\u2194'", 
                     "'\u2295'", "'\u2200'", "'\u2203'" ]

    symbolicNames = [ "<INVALID>", "IDENTIFIER", "PREDICATE_START", "PREMISES_START", 
                      "CONCLUSION_START", "SEP", "QUE", "UND", "LPAREN", 
                      "RPAREN", "NOT", "CONJ", "DISJ", "IMPL", "BICOND", 
                      "XOR", "FORALL", "EXISTS", "IGNORE_NEWLINE", "NEWLINE", 
                      "LINE_ESCAPE", "WHITESPACE", "SL_COMMENT" ]

    RULE_start = 0
    RULE_predicates = 1
    RULE_predicate = 2
    RULE_premises = 3
    RULE_conclusion = 4
    RULE_formula = 5
    RULE_term = 6
    RULE_bin_connective = 7
    RULE_quantifier = 8
    RULE_ind_constant = 9
    RULE_var_constant = 10
    RULE_pred_constant = 11

    ruleNames =  [ "start", "predicates", "predicate", "premises", "conclusion", 
                   "formula", "term", "bin_connective", "quantifier", "ind_constant", 
                   "var_constant", "pred_constant" ]

    EOF = Token.EOF
    IDENTIFIER=1
    PREDICATE_START=2
    PREMISES_START=3
    CONCLUSION_START=4
    SEP=5
    QUE=6
    UND=7
    LPAREN=8
    RPAREN=9
    NOT=10
    CONJ=11
    DISJ=12
    IMPL=13
    BICOND=14
    XOR=15
    FORALL=16
    EXISTS=17
    IGNORE_NEWLINE=18
    NEWLINE=19
    LINE_ESCAPE=20
    WHITESPACE=21
    SL_COMMENT=22

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicates(self):
            return self.getTypedRuleContext(folParser.PredicatesContext,0)


        def premises(self):
            return self.getTypedRuleContext(folParser.PremisesContext,0)


        def conclusion(self):
            return self.getTypedRuleContext(folParser.ConclusionContext,0)


        def EOF(self):
            return self.getToken(folParser.EOF, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def getRuleIndex(self):
            return folParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = folParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 27
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.NEWLINE:
                self.state = 24
                self.match(folParser.NEWLINE)
                self.state = 29
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 30
            self.predicates()
            self.state = 32 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 31
                self.match(folParser.NEWLINE)
                self.state = 34 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==folParser.NEWLINE):
                    break

            self.state = 36
            self.premises()
            self.state = 38 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 37
                self.match(folParser.NEWLINE)
                self.state = 40 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==folParser.NEWLINE):
                    break

            self.state = 42
            self.conclusion()
            self.state = 46
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.NEWLINE:
                self.state = 43
                self.match(folParser.NEWLINE)
                self.state = 48
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 49
            self.match(folParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicatesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREDICATE_START(self):
            return self.getToken(folParser.PREDICATE_START, 0)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.PredicateContext)
            else:
                return self.getTypedRuleContext(folParser.PredicateContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def getRuleIndex(self):
            return folParser.RULE_predicates

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicates" ):
                listener.enterPredicates(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicates" ):
                listener.exitPredicates(self)




    def predicates(self):

        localctx = folParser.PredicatesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_predicates)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(folParser.PREDICATE_START)
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.NEWLINE:
                self.state = 52
                self.match(folParser.NEWLINE)
                self.state = 57
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 58
            self.predicate()
            self.state = 63
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 59
                    self.match(folParser.NEWLINE)
                    self.state = 60
                    self.predicate() 
                self.state = 65
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pred_constant(self):
            return self.getTypedRuleContext(folParser.Pred_constantContext,0)


        def LPAREN(self):
            return self.getToken(folParser.LPAREN, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.TermContext)
            else:
                return self.getTypedRuleContext(folParser.TermContext,i)


        def RPAREN(self):
            return self.getToken(folParser.RPAREN, 0)

        def SEP(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.SEP)
            else:
                return self.getToken(folParser.SEP, i)

        def getRuleIndex(self):
            return folParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = folParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.pred_constant()
            self.state = 67
            self.match(folParser.LPAREN)
            self.state = 68
            self.term()
            self.state = 73
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.SEP:
                self.state = 69
                self.match(folParser.SEP)
                self.state = 70
                self.term()
                self.state = 75
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 76
            self.match(folParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PremisesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREMISES_START(self):
            return self.getToken(folParser.PREMISES_START, 0)

        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.FormulaContext)
            else:
                return self.getTypedRuleContext(folParser.FormulaContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def getRuleIndex(self):
            return folParser.RULE_premises

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPremises" ):
                listener.enterPremises(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPremises" ):
                listener.exitPremises(self)




    def premises(self):

        localctx = folParser.PremisesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_premises)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(folParser.PREMISES_START)
            self.state = 82
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.NEWLINE:
                self.state = 79
                self.match(folParser.NEWLINE)
                self.state = 84
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 85
            self.formula(0)
            self.state = 90
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 86
                    self.match(folParser.NEWLINE)
                    self.state = 87
                    self.formula(0) 
                self.state = 92
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONCLUSION_START(self):
            return self.getToken(folParser.CONCLUSION_START, 0)

        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.FormulaContext)
            else:
                return self.getTypedRuleContext(folParser.FormulaContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def getRuleIndex(self):
            return folParser.RULE_conclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConclusion" ):
                listener.enterConclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConclusion" ):
                listener.exitConclusion(self)




    def conclusion(self):

        localctx = folParser.ConclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(folParser.CONCLUSION_START)
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==folParser.NEWLINE:
                self.state = 94
                self.match(folParser.NEWLINE)
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 100
            self.formula(0)
            self.state = 105
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 101
                    self.match(folParser.NEWLINE)
                    self.state = 102
                    self.formula(0) 
                self.state = 107
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return folParser.RULE_formula

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class NegationContext(FormulaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.FormulaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(folParser.NOT, 0)
        def formula(self):
            return self.getTypedRuleContext(folParser.FormulaContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegation" ):
                listener.enterNegation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegation" ):
                listener.exitNegation(self)


    class Binary_connectiveContext(FormulaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.FormulaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.FormulaContext)
            else:
                return self.getTypedRuleContext(folParser.FormulaContext,i)

        def bin_connective(self):
            return self.getTypedRuleContext(folParser.Bin_connectiveContext,0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinary_connective" ):
                listener.enterBinary_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinary_connective" ):
                listener.exitBinary_connective(self)


    class QuantificationContext(FormulaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.FormulaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def quantifier(self):
            return self.getTypedRuleContext(folParser.QuantifierContext,0)

        def var_constant(self):
            return self.getTypedRuleContext(folParser.Var_constantContext,0)

        def formula(self):
            return self.getTypedRuleContext(folParser.FormulaContext,0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.NEWLINE)
            else:
                return self.getToken(folParser.NEWLINE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantification" ):
                listener.enterQuantification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantification" ):
                listener.exitQuantification(self)


    class Atomic_formulaContext(FormulaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.FormulaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pred_constant(self):
            return self.getTypedRuleContext(folParser.Pred_constantContext,0)

        def LPAREN(self):
            return self.getToken(folParser.LPAREN, 0)
        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(folParser.TermContext)
            else:
                return self.getTypedRuleContext(folParser.TermContext,i)

        def RPAREN(self):
            return self.getToken(folParser.RPAREN, 0)
        def SEP(self, i:int=None):
            if i is None:
                return self.getTokens(folParser.SEP)
            else:
                return self.getToken(folParser.SEP, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_formula" ):
                listener.enterAtomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_formula" ):
                listener.exitAtomic_formula(self)


    class ParenthesisContext(FormulaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.FormulaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(folParser.LPAREN, 0)
        def formula(self):
            return self.getTypedRuleContext(folParser.FormulaContext,0)

        def RPAREN(self):
            return self.getToken(folParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesis" ):
                listener.enterParenthesis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesis" ):
                listener.exitParenthesis(self)



    def formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = folParser.FormulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_formula, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [folParser.IDENTIFIER]:
                localctx = folParser.Atomic_formulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 109
                self.pred_constant()
                self.state = 110
                self.match(folParser.LPAREN)
                self.state = 111
                self.term()
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==folParser.SEP:
                    self.state = 112
                    self.match(folParser.SEP)
                    self.state = 113
                    self.term()
                    self.state = 118
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 119
                self.match(folParser.RPAREN)
                pass
            elif token in [folParser.LPAREN]:
                localctx = folParser.ParenthesisContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 121
                self.match(folParser.LPAREN)
                self.state = 122
                self.formula(0)
                self.state = 123
                self.match(folParser.RPAREN)
                pass
            elif token in [folParser.NOT]:
                localctx = folParser.NegationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 125
                self.match(folParser.NOT)
                self.state = 126
                self.formula(3)
                pass
            elif token in [folParser.FORALL, folParser.EXISTS]:
                localctx = folParser.QuantificationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 127
                self.quantifier()
                self.state = 128
                self.var_constant()
                self.state = 132
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==folParser.NEWLINE:
                    self.state = 129
                    self.match(folParser.NEWLINE)
                    self.state = 134
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 135
                self.formula(1)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 157
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = folParser.Binary_connectiveContext(self, folParser.FormulaContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_formula)
                    self.state = 139
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 143
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==folParser.NEWLINE:
                        self.state = 140
                        self.match(folParser.NEWLINE)
                        self.state = 145
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 146
                    self.bin_connective()
                    self.state = 150
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==folParser.NEWLINE:
                        self.state = 147
                        self.match(folParser.NEWLINE)
                        self.state = 152
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 153
                    self.formula(3) 
                self.state = 159
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return folParser.RULE_term

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Var_valueContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def var_constant(self):
            return self.getTypedRuleContext(folParser.Var_constantContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_value" ):
                listener.enterVar_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_value" ):
                listener.exitVar_value(self)


    class Ind_valueContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ind_constant(self):
            return self.getTypedRuleContext(folParser.Ind_constantContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInd_value" ):
                listener.enterInd_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInd_value" ):
                listener.exitInd_value(self)



    def term(self):

        localctx = folParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_term)
        try:
            self.state = 162
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [folParser.IDENTIFIER]:
                localctx = folParser.Ind_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 160
                self.ind_constant()
                pass
            elif token in [folParser.QUE]:
                localctx = folParser.Var_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 161
                self.var_constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bin_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return folParser.RULE_bin_connective

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ImplContext(Bin_connectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.Bin_connectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IMPL(self):
            return self.getToken(folParser.IMPL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImpl" ):
                listener.enterImpl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImpl" ):
                listener.exitImpl(self)


    class DisjContext(Bin_connectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.Bin_connectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DISJ(self):
            return self.getToken(folParser.DISJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisj" ):
                listener.enterDisj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisj" ):
                listener.exitDisj(self)


    class ConjContext(Bin_connectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.Bin_connectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONJ(self):
            return self.getToken(folParser.CONJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConj" ):
                listener.enterConj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConj" ):
                listener.exitConj(self)


    class BicondContext(Bin_connectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.Bin_connectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BICOND(self):
            return self.getToken(folParser.BICOND, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBicond" ):
                listener.enterBicond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBicond" ):
                listener.exitBicond(self)


    class XorContext(Bin_connectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.Bin_connectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def XOR(self):
            return self.getToken(folParser.XOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXor" ):
                listener.enterXor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXor" ):
                listener.exitXor(self)



    def bin_connective(self):

        localctx = folParser.Bin_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_bin_connective)
        try:
            self.state = 169
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [folParser.CONJ]:
                localctx = folParser.ConjContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 164
                self.match(folParser.CONJ)
                pass
            elif token in [folParser.DISJ]:
                localctx = folParser.DisjContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 165
                self.match(folParser.DISJ)
                pass
            elif token in [folParser.IMPL]:
                localctx = folParser.ImplContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 166
                self.match(folParser.IMPL)
                pass
            elif token in [folParser.BICOND]:
                localctx = folParser.BicondContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 167
                self.match(folParser.BICOND)
                pass
            elif token in [folParser.XOR]:
                localctx = folParser.XorContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 168
                self.match(folParser.XOR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return folParser.RULE_quantifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ForallContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FORALL(self):
            return self.getToken(folParser.FORALL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForall" ):
                listener.enterForall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForall" ):
                listener.exitForall(self)


    class ExistsContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a folParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXISTS(self):
            return self.getToken(folParser.EXISTS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExists" ):
                listener.enterExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExists" ):
                listener.exitExists(self)



    def quantifier(self):

        localctx = folParser.QuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_quantifier)
        try:
            self.state = 173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [folParser.FORALL]:
                localctx = folParser.ForallContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 171
                self.match(folParser.FORALL)
                pass
            elif token in [folParser.EXISTS]:
                localctx = folParser.ExistsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 172
                self.match(folParser.EXISTS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ind_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(folParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return folParser.RULE_ind_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInd_constant" ):
                listener.enterInd_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInd_constant" ):
                listener.exitInd_constant(self)




    def ind_constant(self):

        localctx = folParser.Ind_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ind_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(folParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUE(self):
            return self.getToken(folParser.QUE, 0)

        def IDENTIFIER(self):
            return self.getToken(folParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return folParser.RULE_var_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_constant" ):
                listener.enterVar_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_constant" ):
                listener.exitVar_constant(self)




    def var_constant(self):

        localctx = folParser.Var_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_var_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(folParser.QUE)
            self.state = 178
            self.match(folParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pred_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(folParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return folParser.RULE_pred_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPred_constant" ):
                listener.enterPred_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPred_constant" ):
                listener.exitPred_constant(self)




    def pred_constant(self):

        localctx = folParser.Pred_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_pred_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(folParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[5] = self.formula_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def formula_sempred(self, localctx:FormulaContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         




